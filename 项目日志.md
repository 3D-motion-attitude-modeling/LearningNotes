# 项目日志

## 2022年11月27日

**Kinect部分**

* openpose连接网络摄像头

  1. 查看是否有摄像头usb驱动：`ls /dev/v*` 如果结果含有 `/dev/video0` 则有。

  2. 查看usb信息： `lsusb` 查看哪一个是连接的摄像头。

     经查，kinect摄像头ID为 `045e:097a~e` 

* 使用openpose模型

  * https://github.com/CMU-Perceptual-Computing-Lab/openpose/blob/master/doc
  * cmd方法：在 `~/3d_motion/openpose/openpose` 目录下输入命令，注意退出conda： `conda deactivate`
  * 得到姿态点（2d）：保存为 `.json` 文件，注意专门准备一个文件夹存放，因为它会保存每一帧的姿态点。

* linux系统卡死

  `ctrl+alt+T` 打开一个新的命令行，输入 `sudo pkill Xorg` 注销桌面，重新登陆用户即可。**不要直接重启！！** 

## 2023年2月17日

**Kinect部分**

* 开启kinect时需要管理员权限！ `sudo k4aviewer`

  否则会报错 `Is the device being used by another application?`

* Kinect 使用的主要文件的安装位置

  * `k4aviewer  /usr/bin/k4aviewer `
  * `k4a.h /usr/include/k4a/k4a.h`

## 2023年2月18日

**Kinect部分**

* 进展：安装了附带 example 的 Kinect SDK源码； 使用 cmake 成功编译示例程序。
* 安装 Kinect SDK 源码：http://t.csdn.cn/rRdsC
  * 1.7.2安装ninja一步给的域名错误！应为`https://github.com/ninja-build/ninja-git`
  * cmake前需要手动下载一项（文档中有），下载好之后再cmake。报错没关系，只要检查 `/extern/libusb` 等文件夹中已经下载好文件即可进行后续步骤。
* 编译 Kinect 应用程序
  * 在 `/examples/CMakelists.txt` 中添加 `find_package(k4a REQUIRED)` 等语句！（非常重要，否则cmake时会报错：找不到 k4a::k4a）
  * 关于 cmake 的更多内容还需学习。
* 其他
  * 遇到报错时先试试 **sudo** ！！
  * 运行程序时注意，当前 Kinect 的编号是 0， 传参时不要出错。
  * 下载时卡住，可能是 github 崩了

---

**Openpose部分**

- 今天重新编译Openpose代码，出现如下问题：

  ```
  nvcc fatal : Unsupported gpu architecture 'compute_80' 
  ```

  查阅资料得知，是当前电脑显卡算力不支持8.0。

  经过查找[Nvidia官网](https://developer.nvidia.com/cuda-gpus)，显卡Quadro P4000的算力为6.1。

  解决方法参考[网站](https://blog.csdn.net/haiy2011/article/details/128968934)，在 `openpose/cmake/Cuda.cmake` 文件夹，将不支持的算力注释掉即可。


- openpose源代码理解

  - `std::make_shared <FlirReader> (cameraParameterPath, cameraResolution, undistortImage, std::stoi(producerString));`

    上述代码表示生成一个`shared_ptr` , 该指针指向一个数据类型为 `FlirReader` 的数据，括号内为对应数据的构造函数所需参数。


  - ```c++
    // If custom user Worker in same thread
    else if (!userInputWs.empty())
    workersAux = mergeVectors(userInputWs, workersAux);
    // If OpenPose producer (same thread)
    else if (datumProducerW != nullptr)
    workersAux = mergeVectors({datumProducerW}, workersAux);
    ```

​			   这行代码表明 `userInputWs` 和 `{datumProducerW}` 为同一个类型。

## 2023年2月19日

**Openpose部分**

今天在尝试加入 `WITH_3D_RENDERER` 和 `WITH_CERES` 的标志后重新编译openpose源代码，遇到了如下的BUG信息：

- BUG:  `error: 'integer_sequence' is not a member of  'std'`

  经过查询信息，发现是当前安装的 ceres-solver 版本不匹配所导致的。当使用当前 [官网](http://ceres-solver.org/installation.html#linux) 下载的版本（ `ceres-solver-2.1.0` ）将出现上述问题。

  解决方法是安装旧版本的ceres-solver, 大致过程为卸载新版的ceres-solver，之后安装1.14.0版本即可。具体操作参考[网址](https://blog.csdn.net/qq_41586768/article/details/107541917)，其中 **编译ceres_curve_fiiting** 步骤不需要操作

- WARNING:  在使用cmake gui进行configure操作时，出现有关`OpenGL_GL_PREFERENCE` 的warning信息。

  `OpenGL_GL_PREFERENCE` 原始被设置为 "LEGACY", 但是Openpose推荐设置为 “GLVND”。

  我们采用的解决方法比较暴力，在 `usr/local/share/cmake-3.25/Modules` 目录下找到，`FindOpenGL.cmake` 文件，将其中如下代码注释掉：

  ```cmake
  set(OpenGL_GL_PREFERENCE "LEGACY")
  if ("x${_OpenGL_GL_POLICY}x" STREQUAL "xx")
  	set(_OpenGL_GL_POLICY_WARN 1)
  endif()
  ```

  并修改为：

  ```cmake
  set(OpenGL_GL_PREFERENCE "GLVND")
  ```

  这种做法不推荐，在warning信息中提示使用command_policy()操作，但是没有找到正确的使用方法。

- **BUG:** 

  ```xml
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutSolidSphere'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutDisplayFunc'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutGetModifiers'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutLeaveMainLoop'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutInitWindowPosition'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutSwapBuffers'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutInitWindowSize'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutSolidCone'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutMouseFunc'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutMainLoopEvent'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutPostRedisplay'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutCreateWindow'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutInit'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutKeyboardFunc'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutMotionFunc'
  ../../src/openpose/libopenpose.so.1.7.0: undefined reference to `glutInitDisplayMode'
  collect2: error: ld returned 1 exit status
  examples/deprecated/CMakeFiles/tutorial_api_thread_2_user_input_processing_output_and_datum.bin.dir/build.make:176: recipe for target 'examples/deprecated/tutorial_api_thread_2_user_input_processing_output_and_datum.bin' failed
  make[2]: *** [examples/deprecated/tutorial_api_thread_2_user_input_processing_output_and_datum.bin] Error 1
  CMakeFiles/Makefile2:1176: recipe for target 'examples/deprecated/CMakeFiles/tutorial_api_thread_2_user_input_processing_output_and_datum.bin.dir/all' failed
  make[1]: *** [examples/deprecated/CMakeFiles/tutorial_api_thread_2_user_input_processing_output_and_datum.bin.dir/all] Error 2
  make[1]: *** Waiting for unfinished jobs....
  
  ```

  该错误产生的原因为-lGLU -lGL -lglut没有与编译器链接。发现错误原因是通过参考该[网站 ](https://community.khronos.org/t/error-undefined-reference/17579)，以及和 ChatGPT 的询问中理解的。

  但是上述网站并没有给出如何在Openpose源码的编译下，实现链接操作。通过参考[gitHub上Openpose的Issues](https://github.com/CMU-Perceptual-Computing-Lab/openpose/issues/440)，找到解决问题的关键是修改Openpose目录下的 `CMakeLists.txt` 文件，将如下代码从：

  ```cmake
  if (WITH_3D_RENDERER)
    set(OpenPose_3rdparty_libraries ${OpenPose_3rdparty_libraries} ${GLUT_LIBRARY} ${OPENGL_LIBRARIES})
  endif (WITH_3D_RENDERER) 
  ```

  修改为：

  ```cmake
  if (WITH_3D_RENDERER)
    set(OpenPose_3rdparty_libraries ${OpenPose_3rdparty_libraries} ${GLUT_LIBRARY} ${OPENGL_LIBRARIES} -lGLU -lGL -lglut)
  endif (WITH_3D_RENDERER) 
  ```

  即可成功链接。

- 在今天的debug环节中，ChatGPT虽然没有给出任何一个可以解决问题的方案，但是通过合理营造语境描述错误信息，**可以帮助理解问题产生的原因，以及相关陌生代码文件或是陌生命令行指令**，从而间接的帮助问题的解决。

---

在linux上安装了QQ，用于实时与另一台设备进行信息通讯

---

**相机标定知识篇**

* 相机将三维世界中的物体记录在二维的图片中，因此，可以认为相机是一个函数，输入是三维场景，输出为二维图像。**相机标定**就是找到一个合适的数学模型来描述这个函数。这样，我们就可以利用它的反函数，由二维图像重建三维场景。

  ![](.\pictures\pictures for kw\相机标定原理.png)

* **坐标系**

  为了得到数学模型，我们需要使用坐标系：

  * **世界坐标系(world coordinate system)** 现实世界的绝对坐标系，以现实三维空间中某一点为原点建系，描述相机和物体的坐标。 用 `(Xw, Yw, Zw)` 表示坐标值。

  * **相机(camera)坐标系** 以相机的光心为原点的坐标系，描述物体相对于相机光心的位置。用 `(Xc, Yc, Zc)` 表示坐标值，相机的光轴为Z轴，X、Y轴分别平行于图像坐标系的X、Y轴。

    **光心** 大多数相机都是利用小孔成像原理。将相机透镜组抽象为一个小孔模型，小孔中心即为光心。

  * **图像(image)坐标系** 以CCD图像（即相机拍摄到的原始图像）中心为坐标原点，描述图片中像素的位置。用 `(x, y)` 表示坐标值，单位为现实物理长度（如毫米）。

  * **像素(pixel)坐标系** 以数字图像的左上角为坐标原点，描述图片中像素的位置。用 `(u, v)` 表示坐标值，单位为个（像素个数）

    **原始图像 -> 数字图像** 相机拍摄的图片包含若干像素，每个像素点有它的颜色。数字图像用数字表示每个点的颜色。

![](.\pictures\pictures for kw\图像坐标系与像素坐标系.png)

* 内参矩阵

  采用齐次坐标，使用矩阵将上式表示为

  ![](.\LearningNotes\pictures\pictures for kw\图像坐标系到像素坐标系.jpg)

  其中 `(u0, v0)` 是图像坐标系原点在像素坐标系中的坐标（由上述定义可知，坐标为图像分辨率的一半），`dx` 和 `dy` 分别为每个像素在图像平面对应方向上的物理尺寸。

  相机坐标系到图像坐标系的转换，如下图：

  ![](.\pictures\pictures for kw\相机坐标系到图像坐标系.jpg)

  上式中XYZ为物体在相机坐标系中的位置，为具体数值。

  结合上述两个变换，我们得到**内参矩阵**
  $$
  M=
  \begin{bmatrix}
  \frac{1}{dx} & 0 & u0 \\
  0 & \frac{1}{dy} & v0 \\
  0 & 0 & 1
  \end{bmatrix}
  \begin{bmatrix}
  f & 0 & 0 \\
  0 & f & 0 \\
  0 & 0 & 1
  \end{bmatrix}
  =
  \begin{bmatrix}
  f_x & 0 & u0 \\
  0 & f_y & v0 \\
  0 & 0 & 1
  \end{bmatrix}
  $$
  其中 fx，fy 表示在相机拍摄的图像中，长度等于焦距 f 的一段中包含的像素点个数。称 M 为内参矩阵，是因为矩阵 M 的各个元素值只与相机内部参数有关。**利用内参矩阵，可以方便地从相机坐标系变换到像素坐标系。**

* **外参矩阵**

  要得到世界坐标系到像素坐标系的变换，则需要知道这两个三维坐标系之间的相对旋转矩阵 **R** (3×3)和相对位移矩阵 **T** (3×1)。用矩阵表示变换：

  ![](.\pictures\pictures for kw\外参矩阵.png)

  综上，即可实现完整的变换。上式中，Z~c~ 为物体到光心的距离，即**深度距离**！

* **畸变模型**

  实际的相机并不是完美的小孔成像模型，因此实际成像会有畸变。畸变包括**径向畸变**和**切向畸变**等，是由于焦平面上不同区域对图像的放大率不同形成的画面扭曲变形的现象。

  使用3个畸变参数矫正径向畸变（原理：以光心为圆心，r=0处泰勒展开取前几项）
  $$
  x_{rcorr}=x_p(1+k_1r^2+k_2r^4+k_3r^6) \\
  y_{rcorr}=y_p(1+k_1r^2+k_2r^4+k_3r^6)
  $$
  使用2个畸变参数描述切向畸变
  $$
  x_{tcorr}=x_p+[2p_1x_py_p+p_2(r^2+2x_p^2)] \\
  y_{tcorr}=y_p+[p_1(r^2+2y_p^2)+2p_2x_py_p]
  $$

## 2023年2月21日

**安装 ROS for Azure Kinect DK**

* 官网教程 https://github.com/microsoft/Azure_Kinect_ROS_Driver

* 当前 Kinect 版本为1.4.1

* 安装 ROS 官网教程 https://wiki.ros.org/installation/Ubuntu

  跟着官网教程会出错 `Command: 'catkin_make' not found`

* 使用以下命令（来自 https://blog.csdn.net/haiyinshushe/article/details/84256137）

  1. `sudo sh -c '. /etc/lsb-release && echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" > /etc/apt/sources.list.d/ros-latest.list'`

  2. `sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116`

     如果不行，中间的hkp密钥部分可以使用 `hkp://ha.pool.sks-keyservers.net:80  或  hkp://pgp.mit.edu:80`

  3. `sudo apt-get update`

  4. `sudo apt-get install ros-melodic-desktop-full`

  5. 初始化rosdep

     `sudo apt-get install python-rosdep`

     `sudo rosdep init`

     `rosdep update`

  6. 添加ros环境变量

     `echo "source /opt/ros/melodic/setup.bash" >> ~/.bashrc
     source ~/.bashrc`

  7. 安装rosinstall

  至此ROS安装完成。

* 安装 Kinect ROS http://t.csdn.cn/rRdsC

  1. 下载ROS驱动

     `mkdir -p ~/KinectDK_ws/src
     cd ~/KinectDK_ws/src
     catkin_init_workspace
     git clone https://github.com/microsoft/Azure_Kinect_ROS_Driver.git`

  2. 下载 libk4a 和 libk4a-dev 文件（版本1.4.1）https://packages.microsoft.com/ubuntu/18.04/prod/pool/main/libk/libk4a1.2/

  3. 创建文件夹存放上述文件

     `cd ~/KinectDK_ws/src
     mkdir -p ext/sdk`

     在sdk文件夹下再创建3个文件夹：

     1. bin文件夹: 把编译 SDK 时 build 文件夹里面的那个 bin 文件夹直接拷贝过来
     2. include文件夹：SDK 源码里的include文件夹与从 deb 文件里提取出的 include 文件夹合并，拷贝过来
     3. lib文件夹：从deb文件里提取出的两个lib文件夹合并，拷贝过来 **注意：这里是两个lib文件**

     **注：打开deb文件的方法** 不要解压，右键选择 `Open with other application` 再选择 `Archive Manager`

  4. 编译及启用

     `cd ~/KinectDK_ws
     catkin_make
     catkin_make install
     source ./devel/setup.bash
     roslaunch azure_kinect_ros_driver driver.launch `

     `rviz`

     catlin_make install 一步会报错，原因不明。不会影响后续操作（也许）

     **roslunch 一步若报错，将kinect重启即可**

  * 错误汇总

    `rviz` 需要在另一个命令行中开启（roslaunch需处于运行状态），同时退出conda环境！

## 2/25/2023

### 使用 Ros 标定 Kinect 相机

* 参考文章 http://t.csdn.cn/zQKpg

* 详细步骤

  * 开启 ros 可视化窗口

    `cd ~/KinectDK_ws
    catkin_make
    catkin_make install
    source ./devel/setup.bash
    roslaunch azure_kinect_ros_driver driver.launch `

    然后开启另一个命令行

    `rviz`

  * 显示 Kinect 相机图像

    `Add -> Image -> Image Topic -> /rgb/image_raw`

    （上面是显示RGB图像的例子，也可以显示深度图像等）

  * 安装 ros 标定包

    `sudo apt-get install ros-melodic-camera-calibration`

  * 相机标定

    `rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.024 image:=/rgb/image_raw`


* 用 openpose 标定相机

  * 查看 webcam `v4l2-ctl --list-devices`

  * 官方教程 [openpose/calibration_module.md at master · CMU-Perceptual-Computing-Lab/openpose · GitHub](https://github.com/CMU-Perceptual-Computing-Lab/openpose/blob/master/doc/advanced/calibration_module.md#introduction)

    **注意：标定时需要拍摄足够的照片（至少约150张），否则无法产生标定结果，会报错**  `image could not be opened!`

  * 标定：在 `/openpose/openpose` 下

    `../openpose/build/examples/calibration/calibration.bin --mode 1 --grid_square_size_mm 20.0 --grid_number_inner_corners "8x6" --camera_serial_number 18079958 --calibration_image_dir ../intrinsic/ --camera_parameter_folder models/cameraParameters/`
